-- Create the storage schema if it doesn't exist
CREATE SCHEMA IF NOT EXISTS storage;

-- Create the http_request_queue table if it doesn't exist
CREATE TABLE IF NOT EXISTS storage.http_request_queue (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    url text NOT NULL DEFAULT '',
    method text,
    headers jsonb,
    body text,
    timeout_milliseconds integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    status integer,
    response_body text,
    response_headers jsonb
);

-- Ensure proper indexes
CREATE INDEX IF NOT EXISTS http_request_queue_status_idx ON storage.http_request_queue (status);
CREATE INDEX IF NOT EXISTS http_request_queue_created_at_idx ON storage.http_request_queue (created_at);

-- Add the 'files' bucket to storage if it doesn't exist
INSERT INTO storage.buckets (id, name)
VALUES ('files', 'files')
ON CONFLICT DO NOTHING;

-- Ensure private schema exists
CREATE SCHEMA IF NOT EXISTS private;
ALTER SCHEMA private OWNER TO postgres;

-- Create or replace the uuid_or_null function
CREATE OR REPLACE FUNCTION private.uuid_or_null(str text)
RETURNS uuid
LANGUAGE plpgsql
AS $$
begin
  return str::uuid;
  exception when invalid_text_representation then
    return null;
  end;
$$;

ALTER FUNCTION private.uuid_or_null(str text) OWNER TO postgres;

-- Create the supabase_url function if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_proc 
    WHERE proname = 'supabase_url'
  ) THEN
    CREATE FUNCTION supabase_url()
    RETURNS text
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
    DECLARE
      secret_value text;
    BEGIN
      SELECT decrypted_secret INTO secret_value FROM vault.decrypted_secrets WHERE name = 'supabase_url';
      RETURN secret_value;
    END;
    $$;
  END IF;
END
$$;

-- Create or replace the handle_storage_update function if not already defined elsewhere
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_proc 
    JOIN pg_namespace ON pg_proc.pronamespace = pg_namespace.oid 
    WHERE proname = 'handle_storage_update' AND nspname = 'private'
  ) THEN
    EXECUTE $func$
    CREATE OR REPLACE FUNCTION private.handle_storage_update()
    RETURNS trigger
    LANGUAGE plpgsql
    AS $inner$
    declare
      document_id bigint;
      result int;
    begin
      insert into documents (name, storage_object_id, created_by)
        values (new.path_tokens[2], new.id, new.owner)
        returning id into document_id;

      select
        net.http_post(
          url := supabase_url() || '/functions/v1/process',
          headers := jsonb_build_object(
            'Content-Type', 'application/json',
            'Authorization', current_setting('request.headers')::json->>'authorization'
          ),
          body := jsonb_build_object(
            'document_id', document_id
          )
        )
      into result;

      return null;
    end;
    $inner$;
    $func$;
    
    EXECUTE 'ALTER FUNCTION private.handle_storage_update() OWNER TO postgres;';
  END IF;
END
$$;

-- Create on_file_upload trigger if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger 
    WHERE tgname = 'on_file_upload'
  ) THEN
    CREATE TRIGGER on_file_upload
    AFTER INSERT ON storage.objects
    FOR EACH ROW
    EXECUTE FUNCTION private.handle_storage_update();
  END IF;
END
$$;

-- Create storage RLS policies for secure file access
DO $$
BEGIN
  -- Drop policies if they exist to avoid conflicts
  BEGIN
    DROP POLICY IF EXISTS "Authenticated users can upload files" ON storage.objects;
    DROP POLICY IF EXISTS "Users can view their own files" ON storage.objects;
    DROP POLICY IF EXISTS "Users can update their own files" ON storage.objects;
    DROP POLICY IF EXISTS "Users can delete their own files" ON storage.objects;
  EXCEPTION WHEN OTHERS THEN
    -- Ignore errors if policies don't exist
  END;

  -- Create the policies
  CREATE POLICY "Authenticated users can upload files"
  ON storage.objects
  AS PERMISSIVE
  FOR INSERT
  TO authenticated
  WITH CHECK (
    (bucket_id = 'files'::text) AND 
    (owner = auth.uid()) AND 
    (private.uuid_or_null(path_tokens[1]) IS NOT NULL)
  );

  CREATE POLICY "Users can view their own files"
  ON storage.objects
  AS PERMISSIVE
  FOR SELECT
  TO authenticated
  USING (
    (bucket_id = 'files'::text) AND 
    (owner = auth.uid())
  );

  CREATE POLICY "Users can update their own files"
  ON storage.objects
  AS PERMISSIVE
  FOR UPDATE
  TO authenticated
  WITH CHECK (
    (bucket_id = 'files'::text) AND 
    (owner = auth.uid())
  );

  CREATE POLICY "Users can delete their own files"
  ON storage.objects
  AS PERMISSIVE
  FOR DELETE
  TO authenticated
  USING (
    (bucket_id = 'files'::text) AND 
    (owner = auth.uid())
  );
END
$$;

-- Grant necessary permissions
GRANT ALL PRIVILEGES ON SCHEMA storage TO postgres, anon, authenticated, service_role;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA storage TO postgres, anon, authenticated, service_role;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA storage TO postgres, anon, authenticated, service_role;
